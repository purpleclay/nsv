{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NSV","text":"<p><code>nsv</code> (Next Semantic Version) is a convention-based semantic versioning tool that leans on the power of conventional commits to make versioning your software a breeze!</p>"},{"location":"#see-it-in-action","title":"See it in action","text":""},{"location":"#why-another-versioning-tool","title":"Why another versioning tool","text":"<p>There are many semantic versioning tools already out there! But they typically require some configuration or custom scripting in your CI system to make them work. No one likes managing config; it is error-prone, and the slightest tweak ultimately triggers a cascade of change across your projects.</p> <p><code>nsv</code> makes intelligent semantic versioning decisions about your project without needing a config file. It is convention-based and adapts to your semantic workflow by analyzing your commit messages.</p> <p>The power is at your fingertips.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>First-class support for semantic versioning. Conventional commits help give it a nudge in the right direction.</li> <li>Configure your Conventional Commit prefixes for complete control.</li> <li>If you batch your commits per release or prefer a continuous delivery approach, it has you covered.</li> <li>Context-aware, it automatically switches to a monorepo workflow.</li> <li>Extend the power of your commits through commands to dynamically change your semantic release workflow.</li> <li>Patch files with the next semantic version for that complete release workflow.  experimental</li> <li>Get up and running in seconds within GitHub  and GitLab  with the available action or template.</li> <li>First class Dagger  support.</li> </ul>"},{"location":"commands/","title":"Control your workflow with Commands","text":"<p>Conventional Commits is an excellent standard, but sometimes it doesn't fit our semantic versioning needs. Let's consider major version zero application development from the Semantic Versioning (<code>SemVer</code>) 2.0 specification:</p> <pre><code>Major version zero (0.y.z) is for initial development. Anything MAY change at\nany time. The public API SHOULD NOT be considered stable.\n</code></pre> <p>Within this workflow, the largest semantic increase would be a <code>minor</code> increment. Relying purely on the conventional commit standard will not trigger a major increment. As <code>nsv</code> is SemVer compliant, it too will adhere to this, unless explicitly instructed to do so with a command:</p> <pre><code>feat!: expose new sorting functionality over API\n\nTo enable support for server-side sorting, the existing structure of the request\nbody has been modified to compartmentalize sorting criteria\n\nnsv: force~major\n</code></pre>"},{"location":"commands/#commands","title":"Commands","text":"<p>Commands are defined in the footer of a commit message using the case-insensitive <code>nsv:</code> prefix. Like conventional commits, it is a simple way of describing semantic versioning intent and is designed to fit seamlessly into any developer's workflow. When searching for commands, <code>nsv</code> stops at the first one it finds. This is an important distinction between using commands and conventional commits to control SemVer.</p> <p>Multiple commands can be grouped together to achieve your desired outcome:</p> <pre><code>nsv: force~major,pre // (1)!\n</code></pre> <ol> <li>If the existing SemVer was <code>&lt; 1.0.0</code>, these commands combined would generate a SemVer of <code>1.0.0-beta.1</code>. Read on to discover how these commands work.</li> </ol>"},{"location":"commands/#forcing-a-semantic-increment","title":"Forcing a semantic increment","text":"<p>The <code>force</code> command allows a developer to take complete control over the semantic release workflow, ignoring any existing conventional commits. It consists of two parts, a mandatory label <code>force~</code>, followed by the desired semantic increment:</p> <pre><code>nsv: force~major\n</code></pre> <p>For simplicity, there is a one-to-one mapping to all SemVer increments:</p> <ul> <li><code>force~major</code></li> <li><code>force~minor</code></li> <li><code>force~patch</code></li> </ul> <p>If you need to ignore any previous force commands, a break-glass command exists:</p> <ul> <li><code>force~ignore</code></li> </ul>"},{"location":"commands/#prerelease-support","title":"Prerelease support","text":"<p> experimental</p> <p>The <code>pre</code> command allows a developer to initiate a semantic prerelease workflow, which isn't possible through conventional commits. It consists of two parts, a mandatory label <code>pre</code>, followed by an optional prerelease version:</p> <pre><code>nsv: pre~alpha\n</code></pre> <p>There is a one-to-one mapping to common prerelease labels:</p> <ul> <li><code>pre~alpha</code></li> <li><code>pre~beta</code></li> <li><code>pre~rc</code></li> <li><code>pre</code> on its own is equivalent to <code>pre~beta</code></li> </ul> <p>A prerelease version generated by the <code>pre</code> command follows the SemVer convention of:</p> <pre><code>0.1.0-beta.1\n</code></pre> <p>The <code>.1</code> part of the version is automatically incremented by <code>nsv</code> for each subsequent SemVer prerelease. It is reset when transitioning between prerelease labels.</p>"},{"location":"configurable-prefixes/","title":"Configure your Conventional prefixes","text":"<p>Conventional Commits offers a fantastic approach to controlling semantic versioning through commit prefixes. An industry standard convention devised by the Angular team is most commonly used to date.</p> <ul> <li><code>BREAKING CHANGE</code>: any commit with this footer triggers a major update.</li> <li><code>!</code>: any conventional prefix with this suffix (e.g. <code>refactor!</code>) triggers a major update.</li> <li><code>feat</code>: triggers a minor update.</li> <li><code>fix</code>: triggers a patch update.</li> </ul>"},{"location":"configurable-prefixes/#defining-your-own-rules","title":"Defining your own rules","text":"<ul> <li><code>breaking</code>: triggers a major update <code>1.0.0</code> ~&gt; <code>2.0.0</code>.</li> <li><code>feat</code>, <code>deps</code>: triggers a minor update <code>0.1.0</code> ~&gt; <code>0.2.0</code>.</li> <li><code>fix</code>, <code>docs</code>, <code>styles</code>: triggers a patch update <code>0.3.1</code> ~&gt; <code>0.3.2</code>.</li> </ul> ENVCLI <pre><code>NSV_MAJOR_PREFIXES=breaking \\\n  NSV_MINOR_PREFIXES=feat,deps \\\n  NSV_PATCH_PREFIXES=fix,docs,styles \\\n  nsv next\n</code></pre> <pre><code>nsv next --major-prefixes breaking \\\n  --minor-prefixes feat,deps \\\n  --patch-prefixes fix,docs,styles\n</code></pre> <p>Don't worry\u2014when defining your custom prefixes, both the <code>BREAKING CHANGE</code> footer and the <code>!</code> suffix are automatically supported.</p>"},{"location":"configurable-prefixes/#how-prefix-matching-works","title":"How prefix matching works","text":"<p><code>nsv</code> matches a prefix in one of two ways:</p> <ul> <li><code>breaking</code> is a wildcard prefix capable of matching against an optional scope.</li> <li><code>breaking(api)</code> is an exact match only.</li> </ul>"},{"location":"git-repair/","title":"Repair a repository ready for versioning","text":"<p> experimental</p> <p>Sometimes, a git repository is not in the ideal state for versioning, which can impact how <code>nsv</code> behaves.</p>"},{"location":"git-repair/#fixing-a-shallow-clone","title":"Fixing a shallow clone","text":"<p>A git shallow clone limits the amount of history fetched from a repository. It provides performance benefits for day-to-day use but can massively impact <code>nsv</code> as it determines the next semantic version. It is especially problematic when working with a monorepo.</p> <p>Fixing it is a breeze and can be done in one of two ways:</p> <ol> <li> <p>You can let <code>nsv</code> do it for you:</p> ENVCLI <pre><code>NSV_FIX_SHALLOW=true nsv next\n</code></pre> <pre><code>nsv next --fix-shallow\n</code></pre> </li> <li> <p>You can fix it through your CI provider of choice. Please refer to their documentation.</p> </li> </ol>"},{"location":"git-signing/","title":"Git GPG signing","text":"<p>If you require GPG signing, please ensure your git config is correct before running <code>nsv</code>.</p>"},{"location":"git-signing/#importing-a-gpg-key","title":"Importing a GPG key","text":"<p>gpg-import is a tool you can easily integrate into your CI workflow and only needs a single environment variable (<code>GPG_PRIVATE_KEY</code>) to import a GPG key and configure your git config.</p>"},{"location":"git-signing/#committer-impersonation","title":"Committer impersonation","text":"<p>When tagging your repository, <code>nsv</code> will identify the person associated with the commit that triggered the release and dynamically passes these to <code>git</code> through the <code>user.name</code> and <code>user.email</code> config settings.</p> <p>Any of the following conditions will remove the need for impersonation:</p> <ol> <li>The repository has the <code>user.name</code> and <code>user.email</code> settings already defined in git config.</li> <li>The git environment variables <code>GIT_COMMITTER_NAME</code> and <code>GIT_COMMITTER_EMAIL</code> exist.</li> </ol>"},{"location":"hooks/","title":"Executing a custom hook","text":"<p> experimental</p> <p>To further streamline the release workflow, <code>nsv</code> adds support for executing a custom hook before tagging a repository with the next semantic version. The hook's contents are passed to a shell interpreter, which, therefore, supports both inline shell commands or a path to a script, maximizing reconfigurability.</p>"},{"location":"hooks/#a-hooks-context","title":"A hooks context","text":"<p><code>nsv</code> injects the following environment variables into the hooks context:</p> Variable Name Description Example <code>NSV_PREV_TAG</code> The previous semantic version <code>0.2.0</code> <code>NSV_NEXT_TAG</code> The next calculated semantic version based on the commit history <code>0.2.1</code> <code>NSV_WORKING_DIRECTORY</code> The current execution path. Will be a sub-directory for a monorepo <code>src/ui</code> <p>Let's patch the semantic version within a <code>Cargo.toml</code> file to put it into practice.</p> <ol> <li> <p>Add a script to your project (<code>scripts/patch.sh</code>) for patching the file:   <pre><code>#!/bin/sh\nsed -i '' \"s/^version = \\\"$NSV_PREV_TAG\\\"/version = \\\"$NSV_NEXT_TAG\\\"/\" \\\n  \"$NSV_WORKING_DIRECTORY/Cargo.toml\"\n</code></pre></p> </li> <li> <p>Run <code>nsv</code> with the provided hook:   <pre><code>nsv tag --hook \"./scripts/patch.sh\"\n</code></pre></p> </li> </ol>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 - 2024 Purple Clay</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"monorepos/","title":"Monorepos as first-class citizens","text":"<p><code>nsv</code> has been designed so that monorepo support is not an afterthought. Monorepo detection is built-in, removing the need for additional configuration.</p>"},{"location":"monorepos/#understands-its-running-context","title":"Understands its running context","text":"<p>By being context-aware, <code>nsv</code> can detect if it runs within a repository subdirectory, changing how it inspects the commit history. The next semantic version will include the component prefix, a standard monorepo practice<sup>1</sup>.</p> <pre><code>cd src/ui\n</code></pre> <pre><code>$ nsv next\n\nui/0.2.0\n</code></pre> <p>Context paths as command line arguments remove the need to change directories. <code>nsv</code> can version multiple monorepo components in a single pass.</p> <pre><code>$ nsv next src/ui src/search src/database\n\nui/0.3.0,search/0.2.1,database/0.3.0\n</code></pre> <ol> <li> <p>Full customization is supported through Go templating if you want to change this behavior.\u00a0\u21a9</p> </li> </ol>"},{"location":"next-version/","title":"Next Semantic Version","text":"<p><code>nsv</code> core principles of being context-aware and convention-based will let you achieve almost all of your semantic versioning needs when running:</p> <pre><code>nsv next\n</code></pre> <p>By scanning all commit messages within the latest release, <code>nsv</code> understands the author's intent and prints the next semantic version to stdout.</p> <p>If you want to see what is happening under the hood:</p> ENVCLI <pre><code>NSV_SHOW=true nsv next\n</code></pre> <pre><code>nsv next --show\n</code></pre> <pre><code>0.2.0\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 &gt; e0ba951                                        \u2502\n\u2502  \u2191\u2191           \u2502   docs: document new exciting feature            \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2502               \u2502 \u2713 2020953                                        \u2502\n\u2502               \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502               \u2502                                                  \u2502\n\u2502               \u2502 &gt; 709a467                                        \u2502\n\u2502               \u2502   ci: add github workflows                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you need to customize its behavior, environment variables, CLI flags, or commands can be used.</p>"},{"location":"next-version/#configurable-paths-for-monorepo-support","title":"Configurable paths for monorepo support","text":"<p>Monorepo support is important to the design of <code>nsv</code>. By adding support for context paths, multiple semantic versions can be resolved throughout a repository in a single operation.</p> <pre><code>nsv next src/ui src/search\n</code></pre> <p>Any version change will be printed to stdout as a comma separated list in context path order:</p> <pre><code>ui/0.2.1,search/0.3.0\n</code></pre>"},{"location":"next-version/#version-template-customization","title":"Version template customization","text":"<p>Internally <code>nsv</code> utilizes a go template when constructing the next semantic version:</p> <pre><code>{{.Prefix}}{{.Version}}\n</code></pre> <p>Runtime customization of this template is available. For example, you can enforce explicit semantic version usage:</p> ENVCLI <pre><code>NSV_FORMAT=\"{{.SemVer}}\" nsv next\n</code></pre> <pre><code>nsv next --format \"{{.SemVer}}\"\n</code></pre> <p>Head over to the playground to discover more.</p>"},{"location":"options/","title":"Different ways of customizing NSV","text":"<p><code>nsv</code> is designed to be config-free and requires minimal to no runtime options to release your software. If you need to set config, you have one of three ways, ordered from highest to lowest precedence.</p>"},{"location":"options/#cli-flags","title":"CLI flags","text":"<p>A CLI flag is the most explicit way to set an option and will always override the other two methods.</p> <pre><code>nsv next --format \"{{.SemVer}}\" --fix-shallow\n</code></pre>"},{"location":"options/#environment-variables","title":"Environment variables","text":"<p>Environment variables provide great flexibility and support dynamic setting of options, for example, within a CI pipeline.</p> <pre><code>NSV_FORMAT=\"{{.SemVer}}\" NSV_FIX_SHALLOW=\"true\" nsv next\n</code></pre>"},{"location":"options/#dotenv-file","title":"DotEnv file","text":"<p>A <code>.env</code> file located in the root of a project is automatically loaded at runtime and injected into the <code>nsv</code> context.</p> <pre><code>NSV_FORMAT=\"{{.SemVer}}\"\nNSV_FIX_SHALLOW=\"true\"\n</code></pre>"},{"location":"patch-files/","title":"Patch files with the next semantic version","text":"<p> experimental</p> <p>Let <code>nsv</code> patch files in your repository with the next calculated semantic version by executing a custom hook:</p> ENVCLI <pre><code>NSV_HOOK=\"./scripts/patch.sh\" nsv patch\n</code></pre> <pre><code>nsv patch --hook \"./scripts/patch.sh\"\n</code></pre> <p>Any file changes are committed with the default message <code>chore: patched files for release &lt;version&gt;</code>.</p> <p>Auto-patching is on the horizon.</p> <p>Soon, <code>nsv</code> will recognize standard project files and automatically patch them with the next semantic version. How cool is that! </p>"},{"location":"patch-files/#signing-your-commit","title":"Signing your commit","text":"<p>If you require GPG signing, you can configure it here.</p>"},{"location":"patch-files/#using-a-custom-commit-message","title":"Using a custom commit message","text":"<p>You can change the commit message. Support for Go templating provides extra customization.</p> ENVCLI <pre><code>NSV_COMMIT_MESSAGE=\"chore: bumped files to {{.Tag}}\" nsv patch\n</code></pre> <pre><code>nsv patch --commit-message \"chore: bumped files to {{.Tag}}\"\n</code></pre> <p>Resulting in a commit message of:</p> <pre><code>chore: bumped files to 0.2.0\n</code></pre>"},{"location":"patch-files/#version-template-customization","title":"Version template customization","text":"<p>Internally, <code>nsv</code> utilizes a go template to construct the next semantic version. Runtime customization of this template is available here.</p>"},{"location":"playground/","title":"Explore using the Playground","text":"<p> experimental</p> <p>Explore using <code>nsv</code> by launching the in-built playground.</p>"},{"location":"playground/#version-templating","title":"Version templating","text":"<p>Discover how the internal go template is used when generating the next semantic version:</p> <pre><code>nsv playground ui/v0.1.0 --format '{{.Version}}'\n</code></pre> <pre><code>ui/v0.1.0 &gt;&gt; {{.Version}} &gt;&gt; v0.1.0\n\n{{.Prefix}}  &gt;&gt; ui/\n{{.SemVer}}  &gt;&gt; 0.1.0\n{{.Version}} &gt;&gt; v0.1.0\n</code></pre>"},{"location":"playground/#command-composition","title":"Command composition","text":"<p> coming soon</p>"},{"location":"pretty/","title":"Pretty-Printing Output","text":"<p>Support for pretty-printing allows the output of <code>nsv</code> to be customized. A set of in-built options are supported, with more to follow. The default option is <code>full</code> but can be changed:</p> ENVCLI <pre><code>NSV_PRETTY=compact nsv next\n</code></pre> <pre><code>nsv next --pretty compact\n</code></pre> <p>A colorless output</p> <p>Stripping back to basics is easy, set the following environment variable to switch to an ASCII color profile, <code>NO_COLOR=1</code>.</p>"},{"location":"pretty/#full","title":"Full","text":"<p>A tabular format displaying each semantic version change with its associated history, clearly highlighting the triggering commit.</p>"},{"location":"pretty/#compact","title":"Compact","text":"<p>A tabular format with a condensed history, providing a focused overview of any triggering commit.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 \u2713 2020953                                        \u2502\n\u2502  \u2191\u2191           \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tag-version/","title":"Tag the Next Semantic Version","text":"<p>Let <code>nsv</code> tag your repository with the next calculated semantic version:</p> <pre><code>nsv tag\n</code></pre> <p>An annotated tag will be created with the default commit message of <code>chore: tagged release &lt;version&gt;</code>.</p> <p>If you want to see what is happening under the hood:</p> ENVCLI <pre><code>NSV_SHOW=true nsv tag\n</code></pre> <pre><code>nsv tag --show\n</code></pre> <pre><code>0.2.0\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 &gt; e0ba951                                        \u2502\n\u2502  \u2191\u2191           \u2502   docs: document new exciting feature            \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2502               \u2502 \u2713 2020953                                        \u2502\n\u2502               \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502               \u2502                                                  \u2502\n\u2502               \u2502 &gt; 709a467                                        \u2502\n\u2502               \u2502   ci: add github workflows                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tag-version/#configurable-paths-for-monorepo-support","title":"Configurable paths for monorepo support","text":"<p>Monorepo support is important to the design of <code>nsv</code>. By adding support for context paths, multiple semantic versions can be resolved and tagged as a single operation within a repository.</p> <pre><code>nsv tag src/datastore src/notifications\n</code></pre> <p>Any version change will be printed to stdout as a comma separated list in context path order:</p> <pre><code>datastore/0.1.1,notifications/0.3.3\n</code></pre>"},{"location":"tag-version/#using-a-custom-tag-message","title":"Using a custom tag message","text":"<p>If you are not happy with the tag message, you can change it. Support for Go templating provides extra customization.</p> ENVCLI <pre><code>NSV_TAG_MESSAGE=\"chore: tagged release {{.Tag}} from {{.PrevTag}}\" nsv tag\n</code></pre> <pre><code>nsv tag --tag-message \"chore: tagged release {{.Tag}} from {{.PrevTag}}\"\n</code></pre> <p>Resulting in a tag message of:</p> <pre><code>chore: tagged release 0.2.0 from 0.1.0\n</code></pre>"},{"location":"tag-version/#signing-your-commit-or-tag","title":"Signing your commit or tag","text":"<p>If you require GPG signing, you can configure it here.</p>"},{"location":"tag-version/#version-template-customization","title":"Version template customization","text":"<p>Internally <code>nsv</code> utilizes a go template when constructing the next semantic version. Runtime customization of this template is available here.</p>"},{"location":"tag-version/#executing-a-custom-hook","title":"Executing a custom hook","text":"<p>Before tagging your repository, <code>nsv</code> can execute a custom hook. If changes are detected, it will commit them, and then this new commit is tagged.</p> ENVCLI <pre><code>NSV_HOOK=\"./scripts/patch.sh\" nsv tag\n</code></pre> <pre><code>nsv tag --hook \"./scripts/patch.sh\"\n</code></pre> <p>It uses the default commit message of <code>chore: patched files for release &lt;version&gt; [skip ci]</code>.</p>"},{"location":"tag-version/#using-a-custom-commit-message","title":"Using a custom commit message","text":"<p>You can change the commit message. Support for Go templating provides extra customization.</p> ENVCLI <pre><code>NSV_COMMIT_MESSAGE=\"chore: bumped to {{.Tag}} {{.SkipPipelineTag}}\" nsv tag\n</code></pre> <pre><code>nsv tag --commit-message \"chore: bumped to {{.Tag}} {{.SkipPipelineTag}}\"\n</code></pre> <p>Resulting in a commit message of:</p> <pre><code>chore: bumped to 0.2.0 [skip ci]\n</code></pre>"},{"location":"tag-version/#skip-changes-during-a-dry-run","title":"Skip changes during a dry run","text":"<p>Run <code>nsv</code> within dry-run mode to skip tagging your repository and revert any changes a hook makes. This is perfect for testing.</p> ENVCLI <pre><code>NSV_DRY_RUN=\"true\" nsv tag\n</code></pre> <pre><code>nsv tag --dry-run\n</code></pre>"},{"location":"ci/dagger/","title":"Using Dagger in your CI","text":""},{"location":"ci/dagger/#github-action","title":"GitHub Action","text":"<p>Run nsv using the official Dagger GitHub Action. The Dagger Cloud offers enhanced layer caching, which can be enabled by setting a <code>DAGGER_CLOUD_TOKEN</code> environment variable.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  nsv:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GH_NSV }} # (1)!\n\n      - name: Tag\n        uses: dagger/dagger-for-github@v6\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n          GPG_PASSPHRASE: \"${{ secrets.GPG_PASSPHRASE }}\"\n        with:\n          verb: call\n          module: github.com/purpleclay/daggerverse/nsv\n          args: --src . tag --show --gpg-private-key env:GPG_PRIVATE_KEY --gpg-passphrase env:GPG_PASSPHRASE\n          cloud-token: ${{ secrets.DAGGER_CLOUD_TOKEN }}\n</code></pre> <ol> <li>A PAT token triggers another workflow after tagging the repository; this is optional.</li> </ol>"},{"location":"ci/dagger/#gitlab-template","title":"GitLab Template","text":"<p>The same Dagger experience is possible within GitLab using the Purple Clay\u00a0template. The Dagger Cloud offers enhanced layer caching, which can be enabled by setting a <code>DAGGER_CLOUD_TOKEN</code> environment variable.</p> <pre><code>include:\n  - \"https://gitlab.com/purpleclay/templates/-/raw/dagger/0.11.6/dagger/Mixed.gitlab-ci.yml\"\n\n  nsv:\n    extends: [.dagger]\n    stage: release\n    rules:\n      - if: $CI_COMMIT_TAG\n        when: never\n      - if: $CI_PIPELINE_SOURCE == \"schedule\"\n        when: never\n      - if: $CI_MERGE_REQUEST_IID\n        when: never\n      - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n        when: on_success\n    variables:\n      GIT_DEPTH: 0\n      GIT_STRATEGY: clone\n      DAGGER_MODULE: \"github.com/purpleclay/daggerverse/nsv\"\n      DAGGER_ARGS: &gt;-\n        --src .\n        tag\n        --show\n        --paths ${WORKING_DIRECTORY}\n        --gpg-private-key env:NSV_GPG_PRIVATE_KEY\n        --gpg-passphrase env:NSV_GPG_PASSPHRASE\n    before_script: # (1)!\n      - PROJECT_URL=${CI_PROJECT_URL#\"https://\"}\n      - git remote set-url origin \"https://oauth2:${NSV_GITLAB_TOKEN}@${PROJECT_URL}.git\"\n</code></pre> <ol> <li>To push a newly created tag, an access token with\u00a0<code>:write_repository</code>\u00a0permissions is required. Here, it is assigned to the\u00a0<code>NSV_GITLAB_TOKEN</code>\u00a0CI variable.</li> </ol>"},{"location":"ci/github-action/","title":"Using the GitHub action","text":"<p>To get up and running within a GitHub workflow, include the publicly available <code>nsv-action</code> from the GitHub Actions marketplace. You can find details on setting <code>inputs</code>, <code>outputs</code>, and <code>environment variables</code> in the documentation.</p>"},{"location":"ci/github-action/#tagging-a-repository","title":"Tagging a repository","text":"<p>If you wish to tag the repository without triggering another workflow, you must set the permissions of the job to <code>contents: write</code>.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: NSV\n        uses: purpleclay/nsv-action@v1\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n</code></pre>"},{"location":"ci/github-action/#triggering-another-workflow","title":"Triggering another workflow","text":"<p>If you wish to trigger another workflow after <code>nsv</code> tags the repository, you must manually create a token (PAT) with the <code>public_repo</code> permission and use it during the checkout. For best security practice, use a short-lived token.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: \"${{ secrets.TOKEN }}\"\n\n      - name: NSV\n        uses: purpleclay/nsv-action@v1\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n          GPG_PASSPHRASE: \"${{ secrets.GPG_PASSPHRASE }}\"\n</code></pre>"},{"location":"ci/github-action/#capturing-the-next-tag","title":"Capturing the next tag","text":"<p>You can capture the next tag without tagging the repository by setting the <code>next-only</code> input to true.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: NSV\n        id: nsv\n        uses: purpleclay/nsv-action@v1\n        with:\n          next-only: true\n\n      - name: Print Tag\n        run: |\n          echo \"Next calculated tag: ${{ steps.nsv.outputs.nsv }}\"\n</code></pre>"},{"location":"ci/gitlab-template/","title":"Using the GitLab template","text":"<p>To get up and running within a GitLab pipeline, include the publicly available <code>nsv</code> GitLab template. You can find details on setting <code>environment variables</code> in the documentation.</p>"},{"location":"ci/gitlab-template/#tagging-a-repository","title":"Tagging a repository","text":"<pre><code>include:\n  - https://gitlab.com/purpleclay/nsv/-/raw/main/nsv.gitlab-ci.yml\n</code></pre>"},{"location":"install/binary/","title":"Installing the Binary","text":"<p>You can use various package managers to install the <code>nsv</code> binary. Take your pick.</p>"},{"location":"install/binary/#package-managers","title":"Package Managers","text":""},{"location":"install/binary/#apt","title":"Apt","text":"<p>To install using the apt package manager:</p> <pre><code>echo 'deb [trusted=yes] https://fury.purpleclay.dev/apt/ /' \\\n  | sudo tee /etc/apt/sources.list.d/purpleclay.list\nsudo apt update\nsudo apt install -y nsv\n</code></pre> <p>You may need to install the <code>ca-certificates</code> package if you encounter trust issues with regard to the Gemfury certificate:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y ca-certificates\n</code></pre>"},{"location":"install/binary/#aur","title":"Aur","text":"<p>To install from the aur using yay:</p> <pre><code>yay -S nsv-bin\n</code></pre>"},{"location":"install/binary/#homebrew","title":"Homebrew","text":"<p>To use Homebrew:</p> <pre><code>brew install purpleclay/tap/nsv\n</code></pre>"},{"location":"install/binary/#nix-flake","title":"Nix Flake","text":"<p>To use Nix Flakes (highlights illustrate flake changes):</p> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs?ref=nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n\n    nsv = {\n      url = \"github:purpleclay/nsv-nix\";\n      inputs = {\n        nixpkgs.follows = \"nixpkgs\";\n      };\n    };\n  };\n\n  outputs = { self, nixpkgs, flake-utils, nsv }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = nixpkgs.legacyPackages.${system};\n      in\n      with pkgs;\n      {\n        devShells.default = mkShell {\n          buildInputs = [\n            nsv.packages.${system}.nsv\n          ];\n        };\n      }\n    );\n}\n</code></pre>"},{"location":"install/binary/#yum","title":"Yum","text":"<p>To install using the yum package manager:</p> <pre><code>echo '[purpleclay]\nname=purpleclay\nbaseurl=https://fury.purpleclay.dev/yum/\nenabled=1\ngpgcheck=0' | sudo tee /etc/yum.repos.d/purpleclay.repo\nsudo yum install -y nsv\n</code></pre>"},{"location":"install/binary/#linux-packages","title":"Linux Packages","text":"<p>Download and manually install one of the <code>.deb</code>, <code>.rpm</code> or <code>.apk</code> packages from the Releases page.</p> AptYumApk <pre><code>sudo apt install nsv_*.deb\n</code></pre> <pre><code>sudo yum localinstall nsv_*.rpm\n</code></pre> <pre><code>sudo apk add --no-cache --allow-untrusted nsv_*.apk\n</code></pre>"},{"location":"install/binary/#go-install","title":"Go Install","text":"<pre><code>go install github.com/purpleclay/nsv@latest\n</code></pre>"},{"location":"install/binary/#bash-script","title":"Bash Script","text":"<p>To install the latest version using a script:</p> <pre><code>sh -c \"$(curl https://raw.githubusercontent.com/purpleclay/nsv/main/scripts/install.sh)\"\n</code></pre> <p>Download a specific version using the <code>-v</code> flag. The script uses <code>sudo</code> by default but can be disabled through the <code>--no-sudo</code> flag. You can also provide a different installation directory from the default <code>/usr/local/bin</code> by using the <code>-d</code> flag:</p> <pre><code>sh -c \"$(curl https://raw.githubusercontent.com/purpleclay/nsv/main/scripts/install.sh)\" \\\n  -- -v v0.3.0 --no-sudo -d ./bin\n</code></pre>"},{"location":"install/binary/#manual-download-of-binary","title":"Manual download of binary","text":"<p>Head over to the Releases page on GitHub and download any release artefact. Unpack the <code>nsv</code> binary and add it to your <code>PATH</code>.</p>"},{"location":"install/binary/#verifying-a-binary-with-cosign","title":"Verifying a binary with cosign","text":"<p>All binaries can be verified using the checksum file and cosign.</p> <ol> <li>Download the checksum file:</li> </ol> <pre><code>curl -sL https://github.com/purpleclay/nsv/releases/download/v0.10.1/checksums.txt -O\n</code></pre> <ol> <li>Verify the signature of the file:</li> </ol> <pre><code>cosign verify-blob \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.10.1' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  --cert 'https://github.com/purpleclay/nsv/releases/download/v0.10.1/checksums.txt.pem' \\\n  --signature 'https://github.com/purpleclay/nsv/releases/download/v0.10.1/checksums.txt.sig' \\\n  checksums.txt\n</code></pre> <ol> <li>Download any release artifact and verify its SHA256 signature matches the entry within the checksum file:</li> </ol> <pre><code>sha256sum --ignore-missing -c checksums.txt\n</code></pre>"},{"location":"install/source/","title":"Compiling from Source","text":"<p>Download both Go 1.20+ and go-task. Then clone the code from GitHub:</p> <pre><code>git clone https://github.com/purpleclay/nsv.git\ncd nsv\n</code></pre> <p>Build:</p> <pre><code>task\n</code></pre> <p>And check that everything works:</p> <pre><code>./nsv version\n</code></pre>"},{"location":"reference/env-vars/","title":"Available Environment Variables","text":"<p>If you need to customize the behavior of <code>nsv</code> you can use the supported environment variables. Environment variables are perfect for running <code>nsv</code> within your CI workflow.</p>"},{"location":"reference/env-vars/#global-variables","title":"Global Variables","text":"Variable Name Description <code>LOG_LEVEL</code> the level of logging when printing to stderr (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>fatal</code>) <code>NO_COLOR</code> switch to using an ASCII color profile within the terminal <code>NO_LOG</code> disable all log output <code>NSV_FIX_SHALLOW</code> fix a shallow clone of a repository if detected <code>NSV_FORMAT</code> set a go template for formatting the provided tag <code>NSV_MAJOR_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a major semantic version increment <code>NSV_MINOR_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a minor semantic version increment <code>NSV_PATCH_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a patch semantic version increment <code>NSV_PRETTY</code> pretty-print the output of the next semantic version in a given format <code>NSV_SHOW</code> show how the next semantic version was generated"},{"location":"reference/env-vars/#tag-and-patch-variables","title":"Tag and Patch Variables","text":"Variable Name Description <code>NSV_COMMIT_MESSAGE</code> a custom message when committing file changes, supports go text templates.The default is: <code>chore: tagged release {{.Tag}} {{.SkipPipelineTag}}</code> <code>NSV_DRY_RUN</code> no changes will be made to the repository <code>NSV_HOOK</code> a user-defined hook that will be executed before the repository is taggedwith the next semantic version"},{"location":"reference/env-vars/#tag-variables","title":"Tag Variables","text":"Variable Name Description <code>NSV_TAG_MESSAGE</code> a custom message for the annotated tag, supports go text templates. The default is: <code>chore: tagged release {{.Tag}}</code>"},{"location":"reference/templating/","title":"Customization with Templates","text":"<p>Full support for Go templates ensures <code>nsv</code> is incredibly flexible when generating the next semantic version.</p>"},{"location":"reference/templating/#next-semantic-version","title":"Next semantic version","text":"<p>The following annotations represent a semantic version broken down into its parts. And are supported by version customization.</p> Annotation Description Example <code>{{.Prefix}}</code> A monorepo prefix <code>ui/</code> <code>{{.SemVer}}</code> The explicit semantic version. Any leading <code>v</code> prefix will be removed <code>0.1.0</code> <code>{{.Version}}</code> The version number based on the repositories existing naming convention <code>v0.1.0</code>"},{"location":"reference/templating/#tag-annotation-message","title":"Tag annotation message","text":"<p>The following annotations are available for customizing the tag annotation message.</p> Annotation Description Example <code>{{.Tag}}</code> The next calculated semantic version based on the commit history <code>0.2.1</code> <code>{{.PrevTag}}</code> The previous semantic version <code>0.2.0</code>"},{"location":"reference/templating/#commit-message","title":"Commit message","text":"<p>The following annotations are available for customizing the commit message.</p> Annotation Description Example <code>{{.Tag}}</code> The next calculated semantic version based on the commit history <code>0.2.1</code> <code>{{.PrevTag}}</code> The previous semantic version <code>0.2.0</code> <code>{{.SkipPipelineTag}}</code> A CI provider tag for skipping a pipeline build <code>[skip ci]</code>"},{"location":"reference/cli/nsv-next/","title":"nsv next","text":"<pre><code>Generate the next semantic version based on the conventional commit history\nof your repository.\n\nEnvironment Variables:\n\n| Name               | Description                                            |\n|--------------------|--------------------------------------------------------|\n| LOG_LEVEL          | the level of logging when printing to stderr           |\n|                    | (default: info)                                        |\n| NO_COLOR           | switch to using an ASCII color profile within the      |\n|                    | terminal                                               |\n| NO_LOG             | disable all log output                                 |\n| NSV_FIX_SHALLOW    | fix a shallow clone of a repository if detected        |\n| NSV_FORMAT         | provide a go template for changing the default version |\n|                    | format                                                 |\n| NSV_MAJOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | or triggering a major semantic version increment       |\n| NSV_MINOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a minor semantic version increment      |\n| NSV_PATCH_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a patch semantic version increment      |\n| NSV_PRETTY         | pretty-print the output of the next semantic version   |\n|                    | in a given format. The format can be one of either     |\n|                    | full or compact. Must be used in conjunction with      |\n|                    | NSV_SHOW (default: full)                               |\n| NSV_SHOW           | show how the next semantic version was generated       |\n</code></pre>"},{"location":"reference/cli/nsv-next/#usage","title":"Usage","text":"<pre><code>nsv next [&lt;path&gt;...] [flags]\n</code></pre>"},{"location":"reference/cli/nsv-next/#flags","title":"Flags","text":"<pre><code>    --fix-shallow              fix a shallow clone of a repository if detected\n-f, --format string            provide a go template for changing the default\n                               version format\n-h, --help                     help for next\n    --major-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a major semantic version\n                               increment\n    --minor-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a minor semantic version\n                               increment\n    --patch-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a patch semantic version\n                               increment\n-p, --pretty string            pretty-print the output of the next semantic\n                               version in a given format. The format can be one\n                               of either full or compact. Must be used in\n                               conjunction with --show (default \"full\")\n-s, --show                     show how the next semantic version was generated\n</code></pre>"},{"location":"reference/cli/nsv-next/#global-flags","title":"Global Flags","text":"<pre><code>--log-level string   the level of logging when printing to stderr\n                     (default \"info\")\n--no-color           switch to using an ASCII color profile within the terminal\n--no-log             disable all log output\n</code></pre>"},{"location":"reference/cli/nsv-patch/","title":"nsv patch","text":"<pre><code>Patch files in a repository with the next semantic version based on the\nconventional commit history of your repository.\n\nEnvironment Variables:\n\n| Name               | Description                                            |\n|--------------------|--------------------------------------------------------|\n| LOG_LEVEL          | the level of logging when printing to stderr           |\n|                    | (default: info)                                        |\n| NO_COLOR           | switch to using an ASCII color profile within the      |\n|                    | terminal                                               |\n| NO_LOG             | disable all log output                                 |\n| NSV_COMMIT_MESSAGE | a custom message when committing file changes,         |\n|                    | supports go text templates. The default is: \"chore:    |\n|                    | patched files for release {{.Tag}}\"                    |\n| NSV_DRY_RUN        | no changes will be made to the repository              |\n| NSV_FIX_SHALLOW    | fix a shallow clone of a repository if detected        |\n| NSV_FORMAT         | provide a go template for changing the default version |\n|                    | format                                                 |\n| NSV_HOOK           | a user-defined hook that will be executed before any   |\n|                    | file changes are committed with the next semantic      |\n|                    | version                                                |\n| NSV_MAJOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | or triggering a major semantic version increment       |\n| NSV_MINOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a minor semantic version increment      |\n| NSV_PATCH_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a patch semantic version increment      |\n| NSV_PRETTY         | pretty-print the output of the next semantic version   |\n|                    | in a given format. The format can be one of either     |\n|                    | full or compact. Must be used in conjunction with      |\n|                    | NSV_SHOW (default: full)                               |\n| NSV_SHOW           | show how the next semantic version was generated       |\n\nHook Environment Variables:\n\n| Name                  | Description                                         |\n|-----------------------|-----------------------------------------------------|\n| NSV_NEXT_TAG          | the next calculated semantic version                |\n| NSV_PREV_TAG          | the last semantic version as identified within the  |\n|                       | tag                                                 |\n|                       | history of the current repository                   |\n| NSV_WORKING_DIRECTORY | the working directory (or path) relative to the     |\n|                       | root of the current repository. It will be empty if |\n|                       | not a monorepo                                      |\n</code></pre>"},{"location":"reference/cli/nsv-patch/#usage","title":"Usage","text":"<pre><code>nsv patch [&lt;path&gt;...] [flags]\n</code></pre>"},{"location":"reference/cli/nsv-patch/#flags","title":"Flags","text":"<pre><code>-M, --commit-message string    a custom message when committing file changes,\n                               supports go text templates (default \"chore:\n                               patched files for release {{.Tag}}\")\n    --dry-run                  no changes will be made to the repository\n    --fix-shallow              fix a shallow clone of a repository if detected\n-f, --format string            provide a go template for changing the default\n                               version format\n-h, --help                     help for tag\n    --hook string              a user-defined hook that will be executed before\n                               any file changes are committed with the next\n                               semantic version\n    --major-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a major semantic version\n                               increment\n    --minor-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a minor semantic version\n                               increment\n    --patch-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a patch semantic version\n                               increment\n-p, --pretty string            pretty-print the output of the next semantic\n                               version in a given format. The format can be one\n                               of either full or compact. Must be used in\n                               conjunction with --show (default \"full\")\n-s, --show                     show how the next semantic version was generated\n</code></pre>"},{"location":"reference/cli/nsv-patch/#global-flags","title":"Global Flags","text":"<pre><code>--log-level string   the level of logging when printing to stderr\n                     (default \"info\")\n--no-color           switch to using an ASCII color profile within the terminal\n--no-log             disable all log output\n</code></pre>"},{"location":"reference/cli/nsv-playground/","title":"nsv playground","text":"<pre><code>A playground for discovering go template support.\n\nDiscover ways of formatting your repository tag using the in-built\ngo template annotations.\n\nEnvironment Variables:\n\n| Name       | Description                                       |\n|------------|---------------------------------------------------|\n| NSV_FORMAT | set a go template for formatting the provided tag |\n</code></pre>"},{"location":"reference/cli/nsv-playground/#usage","title":"Usage","text":"<pre><code>nsv playground &lt;tag&gt; [flags]\n</code></pre>"},{"location":"reference/cli/nsv-playground/#flags","title":"Flags","text":"<pre><code>-f, --format string   provide a go template for changing the default version\n                      format\n-h, --help            help for playground\n</code></pre>"},{"location":"reference/cli/nsv-tag/","title":"nsv tag","text":"<pre><code>Tag the repository with the next semantic version based on the conventional\ncommit history of your repository.\n\nEnvironment Variables:\n\n| Name               | Description                                            |\n|--------------------|--------------------------------------------------------|\n| LOG_LEVEL          | the level of logging when printing to stderr           |\n|                    | (default: info)                                        |\n| NO_COLOR           | switch to using an ASCII color profile within the      |\n|                    | terminal                                               |\n| NO_LOG             | disable all log output                                 |\n| NSV_COMMIT_MESSAGE | a custom message when committing file changes,         |\n|                    | supports go text templates. The default is: \"chore:    |\n|                    | patched files for release {{.Tag}}                     |\n|                    | {{.SkipPipelineTag}}\"                                  |\n| NSV_DRY_RUN        | no changes will be made to the repository              |\n| NSV_FIX_SHALLOW    | fix a shallow clone of a repository if detected        |\n| NSV_FORMAT         | provide a go template for changing the default version |\n|                    | format                                                 |\n| NSV_HOOK           | a user-defined hook that will be executed before the   |\n|                    | repository is tagged with the next semantic version    |\n| NSV_MAJOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | or triggering a major semantic version increment       |\n| NSV_MINOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a minor semantic version increment      |\n| NSV_PATCH_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a patch semantic version increment      |\n| NSV_PRETTY         | pretty-print the output of the next semantic version   |\n|                    | in a given format. The format can be one of either     |\n|                    | full or compact. Must be used in conjunction with      |\n|                    | NSV_SHOW (default: full)                               |\n| NSV_SHOW           | show how the next semantic version was generated       |\n| NSV_TAG_MESSAGE    | a custom message for the tag, supports go text         |\n|                    | templates. The default is: \"chore: tagged release      |\n|                    | {{.Tag}}\"                                              |\n\nHook Environment Variables:\n\n| Name                  | Description                                         |\n|-----------------------|-----------------------------------------------------|\n| NSV_NEXT_TAG          | the next calculated semantic version                |\n| NSV_PREV_TAG          | the last semantic version as identified within the  |\n|                       | tag                                                 |\n|                       | history of the current repository                   |\n| NSV_WORKING_DIRECTORY | the working directory (or path) relative to the     |\n|                       | root of the current repository. It will be empty if |\n|                       | not a monorepo                                      |\n</code></pre>"},{"location":"reference/cli/nsv-tag/#usage","title":"Usage","text":"<pre><code>nsv tag [&lt;path&gt;...] [flags]\n</code></pre>"},{"location":"reference/cli/nsv-tag/#flags","title":"Flags","text":"<pre><code>-M, --commit-message string    a custom message when committing file changes,\n                               supports go text templates (default \"chore:\n                               tagged release {{.Tag}} {{.SkipPipelineTag}}\")\n    --dry-run                  no changes will be made to the repository\n    --fix-shallow              fix a shallow clone of a repository if detected\n-f, --format string            provide a go template for changing the default\n                               version format\n-h, --help                     help for tag\n    --hook string              a user-defined hook that will be executed before\n                               the repository is tagged with the next semantic\n                               version\n    --major-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a major semantic version\n                               increment\n    --minor-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a minor semantic version\n                               increment\n    --patch-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a patch semantic version\n                               increment\n-p, --pretty string            pretty-print the output of the next semantic\n                               version in a given format. The format can be one\n                               of either full or compact. Must be used in\n                               conjunction with --show (default \"full\")\n-s, --show                     show how the next semantic version was generated\n-A, --tag-message string       a custom message for the annotated tag, supports\n                               go text templates (default \"chore: tagged release\n                               {{.Tag}}\")\n</code></pre>"},{"location":"reference/cli/nsv-tag/#global-flags","title":"Global Flags","text":"<pre><code>--log-level string   the level of logging when printing to stderr\n                     (default \"info\")\n--no-color           switch to using an ASCII color profile within the terminal\n--no-log             disable all log output\n</code></pre>"},{"location":"reference/cli/nsv/","title":"nsv","text":"<pre><code>NSV (Next Semantic Version) is a convention-based semantic versioning tool that\nleans on the power of conventional commits to make versioning your software a\nbreeze!.\n\n## Why another versioning tool\n\nThere are many semantic versioning tools already out there! But they typically\nrequire some configuration or custom scripting in your CI system to make them\nwork. No one likes managing config; it is error-prone, and the slightest tweak\nultimately triggers a cascade of change across your projects.\n\nStep in NSV. Designed to make intelligent semantic versioning decisions about\nyour project without needing a config file. Entirely convention-based, you can\nadapt your workflow from within your commit message.\n\nThe power is at your fingertips.\n\nGlobal Environment Variables:\n\n| Name      | Description                                                  |\n|-----------|--------------------------------------------------------------|\n| LOG_LEVEL | the level of logging when printing to stderr (default: info) |\n| NO_COLOR  | switch to using an ASCII color profile within the terminal   |\n| NO_LOG    | disable all log output                                       |\n</code></pre>"},{"location":"reference/cli/nsv/#usage","title":"Usage","text":"<pre><code>nsv [command]\n</code></pre>"},{"location":"reference/cli/nsv/#commands","title":"Commands","text":"<pre><code>completion  Generate the autocompletion script for the specified shell\nhelp        Help about any command\nnext        Generate the next semantic version\ntag         Tag the repository with the next semantic version\nversion     Print build time version information\n</code></pre>"},{"location":"reference/cli/nsv/#flags","title":"Flags","text":"<pre><code>-h, --help               help for nsv\n    --log-level string   the level of logging when printing to stderr\n                         (default \"info\")\n    --no-color           switch to using an ASCII color profile within the\n                         terminal\n    --no-log             disable all log output\n</code></pre>"},{"location":"running/dagger/","title":"Running with Dagger","text":"<p>Dagger provides a way to define tasks that can run on your favorite CI/CD platform or locally. Powered by Docker, it is incredibly easy to get up and running.</p>"},{"location":"running/dagger/#installing-dagger","title":"Installing Dagger","text":"<p>Read the official documentation for complete instructions.</p> macOSLinuxWindowsNix Flake <pre><code>brew install dagger/tap/dagger\n</code></pre> <pre><code>curl -L https://dl.dagger.io/dagger/install.sh | BIN_DIR=$HOME/.local/bin sh\n</code></pre> <pre><code>Invoke-WebRequest -UseBasicParsing -Uri https://dl.dagger.io/dagger/install.ps1 | Invoke-Expression\n</code></pre> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs?ref=nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n\n    dagger = {\n      url = \"github:dagger/nix\";\n      inputs = {\n        nixpkgs.follows = \"nixpkgs\";\n      };\n    };\n  };\n\n  outputs = { self, nixpkgs, flake-utils, dagger }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = nixpkgs.legacyPackages.${system};\n      in\n      with pkgs;\n      {\n        devShells.default = mkShell {\n          buildInputs = [\n            dagger.packages.${system}.dagger\n          ];\n        };\n      }\n    );\n}\n</code></pre>"},{"location":"running/dagger/#next-semantic-version","title":"Next semantic version","text":"<p>Calculates the next semantic version and prints it to stdout. For full configuration options.</p> <pre><code>dagger call -m github.com/purpleclay/daggerverse/nsv@v0.10.1 --src . next\n</code></pre>"},{"location":"running/dagger/#tagging-the-next-version","title":"Tagging the next version","text":"<p>Tags a repository with the next semantic version. For full configuration options.</p> <pre><code>dagger call -m github.com/purpleclay/daggerverse/nsv@v0.10.1 --src . tag\n</code></pre>"},{"location":"running/dagger/#patching-files-with-the-next-version","title":"Patching files with the next version","text":"<p>Patch files within a repository using the next semantic version. For full configuration options.</p> <pre><code>dagger call -m github.com/purpleclay/daggerverse/nsv@v0.10.1 --src . patch \\\n  --hook \"./scripts/patch.sh\"\n</code></pre>"},{"location":"running/docker/","title":"Running with Docker","text":"<p>You can run <code>nsv</code> directly from a docker image. Just mount your repository as a volume and set it as the working directory.</p> DockerHubGHCR <pre><code>docker run --rm -v $PWD:/work -w /work purpleclay/nsv:v0.10.1\n</code></pre> <pre><code>docker run --rm -v $PWD:/work -w /work ghcr.io/purpleclay/nsv:v0.10.1\n</code></pre>"},{"location":"running/docker/#verifying-with-cosign","title":"Verifying with cosign","text":"<p>Docker images can be verified using cosign.</p> DockerHubGHCR <pre><code>cosign verify \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.10.1' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  purpleclay/nsv:v0.10.1\n</code></pre> <pre><code>cosign verify \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.10.1' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  ghcr.io/purpleclay/nsv:v0.10.1\n</code></pre>"},{"location":"running/nix/","title":"Running with Nix","text":"<p>You can run <code>nsv</code> directly using Nix without directly installing its dependencies.</p>"},{"location":"running/nix/#installing-nix","title":"Installing Nix","text":"<p>Determinate Systems provides a quick and easy installer.</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf -L https://install.determinate.systems/nix | \\\n  sh -s -- install\n</code></pre>"},{"location":"running/nix/#nix-run","title":"Nix Run","text":"<p>With a single command, Nix will build and run <code>nsv</code> within your environment:</p> <pre><code>nix run github:purpleclay/nsv\n</code></pre> <p>Passing command line arguments is also very easy:</p> <pre><code>nix run github:purpleclay/nsv -- next\n</code></pre>"}]}