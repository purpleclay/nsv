{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"NSV","text":"<p><code>nsv</code> (Next Semantic Version) is a convention-based semantic versioning tool that leans on the power of conventional commits to make versioning your software a breeze!</p>"},{"location":"#see-it-in-action","title":"See it in action","text":""},{"location":"#why-another-versioning-tool","title":"Why another versioning tool","text":"<p>There are many semantic versioning tools already out there! But they typically require some configuration or custom scripting in your CI system to make them work. No one likes managing config; it is error-prone, and the slightest tweak ultimately triggers a cascade of change across your projects.</p> <p><code>nsv</code> makes intelligent semantic versioning decisions about your project without needing a config file. It is convention-based and adapts to your semantic workflow by analyzing your commit messages.</p> <p>The power is at your fingertips.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>First-class support for semantic versioning. Conventional commits help give it a nudge in the right direction.</li> <li>Configure your Conventional Commit prefixes for complete control.</li> <li>If you batch your commits per release or prefer a continuous delivery approach, it has you covered.</li> <li>Context-aware, it automatically switches to a monorepo workflow.</li> <li>Extend the power of your commits through commands to dynamically change your semantic release workflow.</li> <li>Explore how to use it within the purpose-built playground.  experimental</li> <li>Get up and running in seconds within GitHub  and GitLab  with the available action or template.</li> <li>First class Dagger  support.  experimental</li> </ul>"},{"location":"commands/","title":"Control your workflow with Commands","text":"<p>Conventional Commits is an excellent standard, but sometimes it doesn't fit our semantic versioning needs. Let's consider major version zero application development from the Semantic Versioning (<code>SemVer</code>) 2.0 specification:</p> <pre><code>Major version zero (0.y.z) is for initial development. Anything MAY change at\nany time. The public API SHOULD NOT be considered stable.\n</code></pre> <p>Within this workflow, the largest semantic increase would be a <code>minor</code> increment. Relying purely on the conventional commit standard will not trigger a major increment. As <code>nsv</code> is SemVer compliant, it too will adhere to this, unless explicitly instructed to do so with a command:</p> <pre><code>feat!: expose new sorting functionality over API\n\nTo enable support for server-side sorting, the existing structure of the request\nbody has been modified to compartmentalize sorting criteria\n\nnsv: force~major\n</code></pre>"},{"location":"commands/#commands","title":"Commands","text":"<p>Commands are defined in the footer of a commit message using the case-insensitive <code>nsv:</code> prefix. Like conventional commits, it is a simple way of describing semantic versioning intent and is designed to fit seamlessly into any developer's workflow. When searching for commands, <code>nsv</code> stops at the first one it finds. This is an important distinction between using commands and conventional commits to control SemVer.</p> <p>Multiple commands can be grouped together to achieve your desired outcome:</p> <pre><code>nsv: force~major,pre // (1)!\n</code></pre> <ol> <li>If the existing SemVer was <code>&lt; 1.0.0</code>, these commands combined would generate a SemVer of <code>1.0.0-beta.1</code>. Read on to discover how these commands work.</li> </ol>"},{"location":"commands/#forcing-a-semantic-increment","title":"Forcing a semantic increment","text":"<p>The <code>force</code> command allows a developer to take complete control over the semantic release workflow, ignoring any existing conventional commits. It consists of two parts, a mandatory label <code>force~</code>, followed by the desired semantic increment:</p> <pre><code>nsv: force~major\n</code></pre> <p>For simplicity, there is a one-to-one mapping to all SemVer increments:</p> <ul> <li><code>force~major</code></li> <li><code>force~minor</code></li> <li><code>force~patch</code></li> </ul> <p>If you need to ignore any previous force commands, a break-glass command exists:</p> <ul> <li><code>force~ignore</code></li> </ul>"},{"location":"commands/#prerelease-support","title":"Prerelease support","text":"<p> experimental</p> <p>The <code>pre</code> command allows a developer to initiate a semantic prerelease workflow, which isn't possible through conventional commits. It consists of two parts, a mandatory label <code>pre</code>, followed by an optional prerelease version:</p> <pre><code>nsv: pre~alpha\n</code></pre> <p>There is a one-to-one mapping to common prerelease labels:</p> <ul> <li><code>pre~alpha</code></li> <li><code>pre~beta</code></li> <li><code>pre~rc</code></li> <li><code>pre</code> on its own is equivalent to <code>pre~beta</code></li> </ul> <p>A prerelease version generated by the <code>pre</code> command follows the SemVer convention of:</p> <pre><code>0.1.0-beta.1\n</code></pre> <p>The <code>.1</code> part of the version is automatically incremented by <code>nsv</code> for each subsequent SemVer prerelease. It is reset when transitioning between prerelease labels.</p>"},{"location":"configurable-prefixes/","title":"Configure your Conventional prefixes","text":"<p>Conventional Commits offers a fantastic approach to controlling semantic versioning through commit prefixes. An industry standard convention devised by the Angular team is most commonly used to date.</p> <ul> <li><code>BREAKING CHANGE</code>: any commit with this footer triggers a major update.</li> <li><code>!</code>: any conventional prefix with this suffix (e.g. <code>refactor!</code>) triggers a major update.</li> <li><code>feat</code>: triggers a minor update.</li> <li><code>fix</code>: triggers a patch update.</li> </ul>"},{"location":"configurable-prefixes/#defining-your-own-rules","title":"Defining your own rules","text":"<ul> <li><code>breaking</code>: triggers a major update <code>1.0.0</code> ~&gt; <code>2.0.0</code>.</li> <li><code>feat</code>, <code>deps</code>: triggers a minor update <code>0.1.0</code> ~&gt; <code>0.2.0</code>.</li> <li><code>fix</code>, <code>docs</code>, <code>styles</code>: triggers a patch update <code>0.3.1</code> ~&gt; <code>0.3.2</code>.</li> </ul> ENVCLI <pre><code>NSV_MAJOR_PREFIXES=breaking \\\n  NSV_MINOR_PREFIXES=feat,deps \\\n  NSV_PATCH_PREFIXES=fix,docs,styles \\\n  nsv next\n</code></pre> <pre><code>nsv next --major-prefixes breaking \\\n  --minor-prefixes feat,deps \\\n  --patch-prefixes fix,docs,styles\n</code></pre> <p>Don't worry\u2014when defining your custom prefixes, both the <code>BREAKING CHANGE</code> footer and the <code>!</code> suffix are automatically supported.</p>"},{"location":"configurable-prefixes/#how-prefix-matching-works","title":"How prefix matching works","text":"<p><code>nsv</code> matches a prefix in one of two ways:</p> <ul> <li><code>breaking</code> is a wildcard prefix capable of matching against an optional scope.</li> <li><code>breaking(api)</code> is an exact match only.</li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2023 - 2024 Purple Clay</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"monorepos/","title":"Monorepos as first-class citizens","text":"<p><code>nsv</code> has been designed so that monorepo support is not an afterthought. Monorepo detection is built-in, removing the need for additional configuration.</p>"},{"location":"monorepos/#understands-its-running-context","title":"Understands its running context","text":"<p>By being context-aware, <code>nsv</code> can detect if it runs within a repository subdirectory, changing how it inspects the commit history. The next semantic version will include the component prefix, a standard monorepo practice<sup>1</sup>.</p> <pre><code>cd src/ui\n</code></pre> <pre><code>$ nsv next\n\nui/0.2.0\n</code></pre> <p>Context paths as command line arguments remove the need to change directories. <code>nsv</code> can version multiple monorepo components in a single pass.</p> <pre><code>$ nsv next src/ui src/search src/database\n\nui/0.3.0,search/0.2.1,database/0.3.0\n</code></pre> <ol> <li> <p>Full customization is supported through Go templating if you want to change this behavior.\u00a0\u21a9</p> </li> </ol>"},{"location":"next-version/","title":"Next Semantic Version","text":"<p><code>nsv</code> core principles of being context-aware and convention-based will let you achieve almost all of your semantic versioning needs when running:</p> <pre><code>nsv next\n</code></pre> <p>By scanning all commit messages within the latest release, <code>nsv</code> understands the author's intent and prints the next semantic version to stdout.</p> <p>If you want to see what is happening under the hood:</p> ENVCLI <pre><code>NSV_SHOW=true nsv next\n</code></pre> <pre><code>nsv next --show\n</code></pre> <pre><code>0.2.0\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 &gt; e0ba951                                        \u2502\n\u2502  \u2191\u2191           \u2502   docs: document new exciting feature            \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2502               \u2502 \u2713 2020953                                        \u2502\n\u2502               \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502               \u2502                                                  \u2502\n\u2502               \u2502 &gt; 709a467                                        \u2502\n\u2502               \u2502   ci: add github workflows                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>If you need to customize its behavior, environment variables, CLI flags, or commands can be used.</p>"},{"location":"next-version/#configurable-paths-for-monorepo-support","title":"Configurable paths for monorepo support","text":"<p>Monorepo support is important to the design of <code>nsv</code>. By adding support for context paths, multiple semantic versions can be resolved throughout a repository in a single operation.</p> <pre><code>nsv next src/ui src/search\n</code></pre> <p>Any version change will be printed to stdout as a comma separated list in context path order:</p> <pre><code>ui/0.2.1,search/0.3.0\n</code></pre>"},{"location":"next-version/#version-template-customization","title":"Version template customization","text":"<p>Internally <code>nsv</code> utilizes a go template when constructing the next semantic version:</p> <pre><code>{{.Prefix}}{{.Version}}\n</code></pre> <p>Runtime customization of this template is available. For example, you can enforce explicit semantic version usage:</p> ENVCLI <pre><code>NSV_FORMAT=\"{{.SemVer}}\" nsv next\n</code></pre> <pre><code>nsv next --format \"{{.SemVer}}\"\n</code></pre> <p>Head over to the playground to discover more.</p>"},{"location":"playground/","title":"Explore using the Playground","text":"<p> experimental</p> <p>Explore using <code>nsv</code> by launching the in-built playground.</p>"},{"location":"playground/#version-templating","title":"Version templating","text":"<p>Discover how the internal go template is used when generating the next semantic version:</p> <pre><code>nsv playground ui/v0.1.0 --format '{{.Version}}'\n</code></pre> <pre><code>ui/v0.1.0 &gt;&gt; {{.Version}} &gt;&gt; v0.1.0\n\n{{.Prefix}}  &gt;&gt; ui/\n{{.SemVer}}  &gt;&gt; 0.1.0\n{{.Version}} &gt;&gt; v0.1.0\n</code></pre>"},{"location":"playground/#command-composition","title":"Command composition","text":"<p> coming soon</p>"},{"location":"pretty/","title":"Pretty-Printing Output","text":"<p>Support for pretty-printing allows the output of <code>nsv</code> to be customized. A set of in-built options are supported, with more to follow. The default option is <code>full</code> but can be changed:</p> ENVCLI <pre><code>NSV_PRETTY=compact nsv next\n</code></pre> <pre><code>nsv next --pretty compact\n</code></pre> <p>A colorless output</p> <p>Stripping back to basics is easy, set the following environment variable to switch to an ASCII color profile, <code>NO_COLOR=1</code>.</p>"},{"location":"pretty/#full","title":"Full","text":"<p>A tabular format displaying each semantic version change with its associated history, clearly highlighting the triggering commit.</p>"},{"location":"pretty/#compact","title":"Compact","text":"<p>A tabular format with a condensed history, providing a focused overview of any triggering commit.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 \u2713 2020953                                        \u2502\n\u2502  \u2191\u2191           \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tag-version/","title":"Tag the Next Semantic Version","text":"<p>Let <code>nsv</code> tag your repository with the next calculated semantic version:</p> <pre><code>nsv tag\n</code></pre> <p>An annotated tag will be created with the default commit message of <code>chore: tagged release &lt;version&gt;</code>.</p> <p>If you want to see what is happening under the hood:</p> ENVCLI <pre><code>NSV_SHOW=true nsv tag\n</code></pre> <pre><code>nsv tag --show\n</code></pre> <pre><code>0.2.0\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  0.2.0        \u2502 &gt; e0ba951                                        \u2502\n\u2502  \u2191\u2191           \u2502   docs: document new exciting feature            \u2502\n\u2502  0.1.0        \u2502                                                  \u2502\n\u2502               \u2502 \u2713 2020953                                        \u2502\n\u2502               \u2502   &gt;&gt;feat&lt;&lt;: a new exciting feature               \u2502\n\u2502               \u2502                                                  \u2502\n\u2502               \u2502 &gt; 709a467                                        \u2502\n\u2502               \u2502   ci: add github workflows                       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"tag-version/#configurable-paths-for-monorepo-support","title":"Configurable paths for monorepo support","text":"<p>Monorepo support is important to the design of <code>nsv</code>. By adding support for context paths, multiple semantic versions can be resolved and tagged as a single operation within a repository.</p> <pre><code>nsv tag src/datastore src/notifications\n</code></pre> <p>Any version change will be printed to stdout as a comma separated list in context path order:</p> <pre><code>datastore/0.1.1,notifications/0.3.3\n</code></pre>"},{"location":"tag-version/#using-a-custom-tag-message","title":"Using a custom tag message","text":"<p>If you are not happy with the tag message, you can change it. Support for Go templating provides extra customization.</p> ENVCLI <pre><code>NSV_TAG_MESSAGE=\"chore: tagged release {{.Tag}} from {{.PrevTag}}\" nsv tag\n</code></pre> <pre><code>nsv tag --message \"chore: tagged release {{.Tag}} from {{.PrevTag}}\"\n</code></pre> <p>Resulting in a tag message:</p> <pre><code>chore: tagged release 0.2.0 from 0.1.0\n</code></pre>"},{"location":"tag-version/#signing-your-tag","title":"Signing your tag","text":"<p>If you require your tag to be signed, please ensure your git config is correct before running <code>nsv</code>. gpg-import is a tool you can easily integrate into your CI workflow and only needs a single environment variable.</p>"},{"location":"tag-version/#version-template-customization","title":"Version template customization","text":"<p>Internally <code>nsv</code> utilizes a go template when constructing the next semantic version. Runtime customization of this template is available here.</p>"},{"location":"tag-version/#committer-impersonation","title":"Committer impersonation","text":"<p>When tagging your repository, <code>nsv</code> will identify the person associated with the commit that triggered the release and dynamically passes these to <code>git</code> through the <code>user.name</code> and <code>user.email</code> config settings.</p> <p>Any of the following conditions will remove the need for impersonation:</p> <ol> <li>The repository has the <code>user.name</code> and <code>user.email</code> settings already defined in git config.</li> <li>The git environment variables <code>GIT_COMMITTER_NAME</code> and <code>GIT_COMMITTER_EMAIL</code> exist.</li> </ol>"},{"location":"ci/dagger/","title":"Using Dagger in your CI","text":"<p> experimental</p>"},{"location":"ci/dagger/#github-action","title":"GitHub Action","text":"<p>Run nsv using the official Dagger GitHub Action. The Dagger Cloud offers enhanced layer caching, which can be enabled by setting a <code>DAGGER_CLOUD_TOKEN</code> environment variable.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  nsv:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n          token: ${{ secrets.GH_NSV }} # (1)!\n\n      - name: Tag\n        uses: dagger/dagger-for-github@v5\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n          GPG_PASSPHRASE: \"${{ secrets.GPG_PASSPHRASE }}\"\n        with:\n          verb: call\n          module: github.com/purpleclay/daggerverse/nsv\n          args: --src . tag --show --gpg-private-key env:GPG_PRIVATE_KEY --gpg-passphrase env:GPG_PASSPHRASE\n          cloud-token: ${{ secrets.DAGGER_CLOUD_TOKEN }}\n</code></pre> <ol> <li>A PAT token triggers another workflow after tagging the repository; this is optional.</li> </ol>"},{"location":"ci/dagger/#gitlab-template","title":"GitLab Template","text":"<p>The same Dagger experience is possible within GitLab using the Purple Clay\u00a0template. The Dagger Cloud offers enhanced layer caching, which can be enabled by setting a <code>DAGGER_CLOUD_TOKEN</code> environment variable.</p> <pre><code>include:\n  - \"https://gitlab.com/purpleclay/templates/-/raw/dagger/0.11.6/dagger/Mixed.gitlab-ci.yml\"\n\n  nsv:\n    extends: [.dagger]\n    stage: release\n    rules:\n      - if: $CI_COMMIT_TAG\n        when: never\n      - if: $CI_PIPELINE_SOURCE == \"schedule\"\n        when: never\n      - if: $CI_MERGE_REQUEST_IID\n        when: never\n      - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n        when: on_success\n    variables:\n      GIT_DEPTH: 0\n      GIT_STRATEGY: clone\n      DAGGER_MODULE: \"github.com/purpleclay/daggerverse/nsv\"\n      DAGGER_ARGS: &gt;-\n        --src .\n        tag\n        --show\n        --paths ${WORKING_DIRECTORY}\n        --gpg-private-key env:NSV_GPG_PRIVATE_KEY\n        --gpg-passphrase env:NSV_GPG_PASSPHRASE\n    before_script: # (1)!\n      - PROJECT_URL=${CI_PROJECT_URL#\"https://\"}\n      - git remote set-url origin \"https://oauth2:${NSV_GITLAB_TOKEN}@${PROJECT_URL}.git\"\n</code></pre> <ol> <li>To push a newly created tag, an access token with\u00a0<code>:write_repository</code>\u00a0permissions is required. Here, it is assigned to the\u00a0<code>NSV_GITLAB_TOKEN</code>\u00a0CI variable.</li> </ol>"},{"location":"ci/github-action/","title":"Using the GitHub action","text":"<p>To get up and running within a GitHub workflow, include the publicly available <code>nsv-action</code> from the GitHub Actions marketplace. You can find details on setting <code>inputs</code>, <code>outputs</code>, and <code>environment variables</code> in the documentation.</p>"},{"location":"ci/github-action/#tagging-a-repository","title":"Tagging a repository","text":"<p>If you wish to tag the repository without triggering another workflow, you must set the permissions of the job to <code>contents: write</code>.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: NSV\n        uses: purpleclay/nsv-action@v1\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n</code></pre>"},{"location":"ci/github-action/#triggering-another-workflow","title":"Triggering another workflow","text":"<p>If you wish to trigger another workflow after <code>nsv</code> tags the repository, you must manually create a token (PAT) with the <code>public_repo</code> permission and use it during the checkout. For best security practice, use a short-lived token.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n          token: \"${{ secrets.TOKEN }}\"\n\n      - name: NSV\n        uses: purpleclay/nsv-action@v1\n        env:\n          GPG_PRIVATE_KEY: \"${{ secrets.GPG_PRIVATE_KEY }}\"\n          GPG_PASSPHRASE: \"${{ secrets.GPG_PASSPHRASE }}\"\n</code></pre>"},{"location":"ci/github-action/#capturing-the-next-tag","title":"Capturing the next tag","text":"<p>You can capture the next tag without tagging the repository by setting the <code>next-only</code> input to true.</p> <pre><code>name: ci\non:\n  push:\n    branches:\n      - main\njobs:\n  ci:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: NSV\n        id: nsv\n        uses: purpleclay/nsv-action@v1\n        with:\n          next-only: true\n\n      - name: Print Tag\n        run: |\n          echo \"Next calculated tag: ${{ steps.nsv.outputs.nsv }}\"\n</code></pre>"},{"location":"ci/gitlab-template/","title":"Using the GitLab template","text":"<p>To get up and running within a GitLab pipeline, include the publicly available <code>nsv</code> GitLab template. You can find details on setting <code>environment variables</code> in the documentation.</p>"},{"location":"ci/gitlab-template/#tagging-a-repository","title":"Tagging a repository","text":"<pre><code>include:\n  - https://gitlab.com/purpleclay/nsv/-/raw/main/nsv.gitlab-ci.yml\n</code></pre>"},{"location":"docker/dagger/","title":"Running with Dagger","text":"<p> experimental</p> <p>Dagger provides a way to define tasks that can run on your favorite CI/CD platform or locally. Powered by Docker, it is incredibly easy to get up and running.</p>"},{"location":"docker/dagger/#installing-dagger","title":"Installing Dagger","text":"<p>Read the official documentation for complete instructions.</p> macOSLinuxWindowsNix Flake <pre><code>brew install dagger/tap/dagger\n</code></pre> <pre><code>curl -L https://dl.dagger.io/dagger/install.sh | BIN_DIR=$HOME/.local/bin sh\n</code></pre> <pre><code>Invoke-WebRequest -UseBasicParsing -Uri https://dl.dagger.io/dagger/install.ps1 | Invoke-Expression\n</code></pre> <pre><code>{\n  inputs = {\n    nixpkgs.url = \"github:nixos/nixpkgs?ref=nixos-unstable\";\n    flake-utils.url = \"github:numtide/flake-utils\";\n\n    dagger = {\n      url = \"github:dagger/nix\";\n      inputs = {\n        nixpkgs.follows = \"nixpkgs\";\n      };\n    };\n  };\n\n  outputs = { self, nixpkgs, flake-utils, dagger }:\n    flake-utils.lib.eachDefaultSystem (system:\n      let\n        pkgs = nixpkgs.legacyPackages.${system};\n      in\n      with pkgs;\n      {\n        devShells.default = mkShell {\n          buildInputs = [\n            dagger.packages.${system}.dagger\n          ];\n        };\n      }\n    );\n}\n</code></pre>"},{"location":"docker/dagger/#next-semantic-version","title":"Next semantic version","text":"<p>Calculates the next semantic version and prints it to stdout. For full configuration options.</p> <pre><code>dagger call -m github.com/purpleclay/daggerverse/nsv --src . next\n</code></pre>"},{"location":"docker/dagger/#tagging-the-next-version","title":"Tagging the next version","text":"<p>Tags a repository with the next semantic version. For full configuration options.</p> <pre><code>dagger call -m github.com/purpleclay/daggerverse/nsv --src . tag\n</code></pre>"},{"location":"docker/running/","title":"Running with Docker","text":"<p>You can run <code>nsv</code> directly from a docker image. Just mount your repository as a volume and set it as the working directory.</p> DockerHubGHCR <pre><code>docker run --rm -v $PWD:/work -w /work purpleclay/nsv:v0.8.0\n</code></pre> <pre><code>docker run --rm -v $PWD:/work -w /work ghcr.io/purpleclay/nsv:v0.8.0\n</code></pre>"},{"location":"docker/running/#verifying-with-cosign","title":"Verifying with cosign","text":"<p>Docker images can be verified using cosign.</p> DockerHubGHCR <pre><code>cosign verify \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.8.0' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  purpleclay/nsv:v0.8.0\n</code></pre> <pre><code>cosign verify \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.8.0' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  ghcr.io/purpleclay/nsv:v0.8.0\n</code></pre>"},{"location":"install/binary/","title":"Installing the Binary","text":"<p>You can use various package managers to install the <code>nsv</code> binary. Take your pick.</p>"},{"location":"install/binary/#package-managers","title":"Package Managers","text":""},{"location":"install/binary/#homebrew","title":"Homebrew","text":"<p>To use Homebrew:</p> <pre><code>brew install purpleclay/tap/nsv\n</code></pre>"},{"location":"install/binary/#apt","title":"Apt","text":"<p>To install using the apt package manager:</p> <pre><code>echo 'deb [trusted=yes] https://fury.purpleclay.dev/apt/ /' \\\n  | sudo tee /etc/apt/sources.list.d/purpleclay.list\nsudo apt update\nsudo apt install -y nsv\n</code></pre> <p>You may need to install the <code>ca-certificates</code> package if you encounter trust issues with regard to the Gemfury certificate:</p> <pre><code>sudo apt update &amp;&amp; sudo apt install -y ca-certificates\n</code></pre>"},{"location":"install/binary/#yum","title":"Yum","text":"<p>To install using the yum package manager:</p> <pre><code>echo '[purpleclay]\nname=purpleclay\nbaseurl=https://fury.purpleclay.dev/yum/\nenabled=1\ngpgcheck=0' | sudo tee /etc/yum.repos.d/purpleclay.repo\nsudo yum install -y nsv\n</code></pre>"},{"location":"install/binary/#aur","title":"Aur","text":"<p>To install from the aur using yay:</p> <pre><code>yay -S nsv-bin\n</code></pre>"},{"location":"install/binary/#linux-packages","title":"Linux Packages","text":"<p>Download and manually install one of the <code>.deb</code>, <code>.rpm</code> or <code>.apk</code> packages from the Releases page.</p> AptYumApk <pre><code>sudo apt install nsv_*.deb\n</code></pre> <pre><code>sudo yum localinstall nsv_*.rpm\n</code></pre> <pre><code>sudo apk add --no-cache --allow-untrusted nsv_*.apk\n</code></pre>"},{"location":"install/binary/#go-install","title":"Go Install","text":"<pre><code>go install github.com/purpleclay/nsv@latest\n</code></pre>"},{"location":"install/binary/#bash-script","title":"Bash Script","text":"<p>To install the latest version using a script:</p> <pre><code>sh -c \"$(curl https://raw.githubusercontent.com/purpleclay/nsv/main/scripts/install)\"\n</code></pre> <p>Download a specific version using the <code>-v</code> flag. The script uses <code>sudo</code> by default but can be disabled through the <code>--no-sudo</code> flag. You can also provide a different installation directory from the default <code>/usr/local/bin</code> by using the <code>-d</code> flag:</p> <pre><code>sh -c \"$(curl https://raw.githubusercontent.com/purpleclay/nsv/main/scripts/install)\" \\\n  -- -v v0.3.0 --no-sudo -d ./bin\n</code></pre>"},{"location":"install/binary/#manual-download-of-binary","title":"Manual download of binary","text":"<p>Head over to the Releases page on GitHub and download any release artefact. Unpack the <code>nsv</code> binary and add it to your <code>PATH</code>.</p>"},{"location":"install/binary/#verifying-a-binary-with-cosign","title":"Verifying a binary with cosign","text":"<p>All binaries can be verified using the checksum file and cosign.</p> <ol> <li>Download the checksum file:</li> </ol> <pre><code>curl -sL https://github.com/purpleclay/nsv/releases/download/v0.3.0/checksums.txt -O\n</code></pre> <ol> <li>Verify the signature of the file:</li> </ol> <pre><code>cosign verify-blob \\\n  --certificate-identity 'https://github.com/purpleclay/nsv/.github/workflows/release.yml@refs/tags/v0.3.0' \\\n  --certificate-oidc-issuer 'https://token.actions.githubusercontent.com' \\\n  --cert 'https://github.com/purpleclay/nsv/releases/download/v0.3.0/checksums.txt.pem' \\\n  --signature 'https://github.com/purpleclay/nsv/releases/download/v0.3.0/checksums.txt.sig' \\\n  checksums.txt\n</code></pre> <ol> <li>Download any release artifact and verify its SHA256 signature matches the entry within the checksum file:</li> </ol> <pre><code>sha256sum --ignore-missing -c checksums.txt\n</code></pre>"},{"location":"install/source/","title":"Compiling from Source","text":"<p>Download both Go 1.20+ and go-task. Then clone the code from GitHub:</p> <pre><code>git clone https://github.com/purpleclay/nsv.git\ncd nsv\n</code></pre> <p>Build:</p> <pre><code>task\n</code></pre> <p>And check that everything works:</p> <pre><code>./nsv version\n</code></pre>"},{"location":"reference/env-vars/","title":"Dynamic Configuration with Environment Variables","text":"<p>If you need to customize the behavior of <code>nsv</code> you can use the supported environment variables. Environment variables provide a dynamic approach to configuration perfect for integrating <code>nsv</code> into your CI workflow.</p>"},{"location":"reference/env-vars/#variables","title":"Variables","text":"Variable Name Description <code>LOG_LEVEL</code> the level of logging when printing to stderr (<code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code>, <code>fatal</code>) <code>NO_COLOR</code> switch to using an ASCII color profile within the terminal <code>NO_LOG</code> disable all log output <code>NSV_FORMAT</code> set a go template for formatting the provided tag <code>NSV_MAJOR_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a major semantic version increment <code>NSV_MINOR_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a minor semantic version increment <code>NSV_PATCH_PREFIXES</code> a comma separated list of conventional commit prefixes for triggering a patch semantic version increment <code>NSV_PRETTY</code> pretty-print the output of the next semantic version in a given format <code>NSV_SHOW</code> show how the next semantic version was generated <code>NSV_TAG_MESSAGE</code> a custom message for the tag, overrides the default:<code>chore: tagged release &lt;version&gt;</code>"},{"location":"reference/templating/","title":"Customization with Templates","text":"<p>Full support for Go templates ensures <code>nsv</code> is incredibly flexible when generating the next semantic version.</p>"},{"location":"reference/templating/#next-semantic-version","title":"Next semantic version","text":"<p>The following annotations represent a semantic version broken down into its parts. And are supported by version customization.</p> Annotation Description Example <code>{{.Prefix}}</code> A monorepo prefix <code>ui/</code> <code>{{.SemVer}}</code> The explicit semantic version. Any leading <code>v</code> prefix will be removed <code>0.1.0</code> <code>{{.Version}}</code> The version number based on the repositories existing naming convention <code>v0.1.0</code>"},{"location":"reference/templating/#tag-annotation-message","title":"Tag annotation message","text":"<p>The following annotations are available for customizing the tag annotation message.</p> Annotation Description Example <code>{{.Tag}}</code> The next calculated semantic version based on the commit history <code>0.2.1</code> <code>{{.PrevTag}}</code> The previous semantic version <code>0.2.0</code>"},{"location":"reference/cli/nsv-next/","title":"nsv next","text":"<pre><code>Generate the next semantic version based on the conventional commit history\nof your repository.\n\nEnvironment Variables:\n\n| Name               | Description                                            |\n|--------------------|--------------------------------------------------------|\n| LOG_LEVEL          | the level of logging when printing to stderr           |\n|                    | (default: info)                                        |\n| NO_COLOR           | switch to using an ASCII color profile within the      |\n|                    | terminal                                               |\n| NO_LOG             | disable all log output                                 |\n| NSV_FORMAT         | provide a go template for changing the default version |\n|                    | format                                                 |\n| NSV_MAJOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | or triggering a major semantic version increment       |\n| NSV_MINOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a minor semantic version increment      |\n| NSV_PATCH_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a patch semantic version increment      |\n| NSV_PRETTY         | pretty-print the output of the next semantic version   |\n|                    | in a given format. The format can be one of either     |\n|                    | full or compact. Must be used in conjunction with      |\n|                    | NSV_SHOW (default: full)                               |\n| NSV_SHOW           | show how the next semantic version was generated       |\n</code></pre>"},{"location":"reference/cli/nsv-next/#usage","title":"Usage","text":"<pre><code>nsv next [&lt;path&gt;...] [flags]\n</code></pre>"},{"location":"reference/cli/nsv-next/#flags","title":"Flags","text":"<pre><code>-f, --format string            provide a go template for changing the default\n                               version format\n-h, --help                     help for next\n    --major-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a major semantic version\n                               increment\n    --minor-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a minor semantic version\n                               increment\n    --patch-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a patch semantic version\n                               increment\n-p, --pretty string            pretty-print the output of the next semantic\n                               version in a given format. The format can be one\n                               of either full or compact. Must be used in\n                               conjunction with --show (default \"full\")\n-s, --show                     show how the next semantic version was generated\n</code></pre>"},{"location":"reference/cli/nsv-next/#global-flags","title":"Global Flags","text":"<pre><code>--log-level string   the level of logging when printing to stderr\n                     (default \"info\")\n--no-color           switch to using an ASCII color profile within the terminal\n--no-log             disable all log output\n</code></pre>"},{"location":"reference/cli/nsv-playground/","title":"nsv playground","text":"<pre><code>A playground for discovering go template support.\n\nDiscover ways of formatting your repository tag using the in-built\ngo template annotations.\n\nEnvironment Variables:\n\n| Name       | Description                                       |\n|------------|---------------------------------------------------|\n| NSV_FORMAT | set a go template for formatting the provided tag |\n</code></pre>"},{"location":"reference/cli/nsv-playground/#usage","title":"Usage","text":"<pre><code>nsv playground &lt;tag&gt; [flags]\n</code></pre>"},{"location":"reference/cli/nsv-playground/#flags","title":"Flags","text":"<pre><code>-f, --format string   provide a go template for changing the default version\n                      format\n-h, --help            help for playground\n</code></pre>"},{"location":"reference/cli/nsv-tag/","title":"nsv tag","text":"<pre><code>Tag the repository with the next semantic version based on the conventional\ncommit history of your repository.\n\nEnvironment Variables:\n\n| Name               | Description                                            |\n|--------------------|--------------------------------------------------------|\n| LOG_LEVEL          | the level of logging when printing to stderr           |\n|                    | (default: info)                                        |\n| NO_COLOR           | switch to using an ASCII color profile within the      |\n|                    | terminal                                               |\n| NO_LOG             | disable all log output                                 |\n| NSV_FORMAT         | provide a go template for changing the default version |\n|                    | format                                                 |\n| NSV_MAJOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | or triggering a major semantic version increment       |\n| NSV_MINOR_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a minor semantic version increment      |\n| NSV_PATCH_PREFIXES | a comma separated list of conventional commit prefixes |\n|                    | for triggering a patch semantic version increment      |\n| NSV_PRETTY         | pretty-print the output of the next semantic version   |\n|                    | in a given format. The format can be one of either     |\n|                    | full or compact. Must be used in conjunction with      |\n|                    | NSV_SHOW (default: full)                               |\n| NSV_SHOW           | show how the next semantic version was generated       |\n| NSV_TAG_MESSAGE    | a custom message for the tag, supports go text         |\n|                    | templates. The default is: \"chore: tagged release      |\n|                    | {{.Tag}}\"                                              |\n</code></pre>"},{"location":"reference/cli/nsv-tag/#usage","title":"Usage","text":"<pre><code>nsv tag [&lt;path&gt;...] [flags]\n</code></pre>"},{"location":"reference/cli/nsv-tag/#flags","title":"Flags","text":"<pre><code>-f, --format string            provide a go template for changing the default\n                               version format\n-h, --help                     help for tag\n    --major-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a major semantic version\n                               increment\n-m, --message string           a custom message for the tag, supports go text\n                               templates (default \"chore: tagged release\n                               {{.Tag}}\")\n    --minor-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a minor semantic version\n                               increment\n    --patch-prefixes strings   a comma separated list of conventional commit\n                               prefixes for triggering a patch semantic version\n                               increment\n-p, --pretty string            pretty-print the output of the next semantic\n                               version in a given format. The format can be one\n                               of either full or compact. Must be used in\n                               conjunction with --show (default \"full\")\n-s, --show                     show how the next semantic version was generated\n</code></pre>"},{"location":"reference/cli/nsv-tag/#global-flags","title":"Global Flags","text":"<pre><code>--log-level string   the level of logging when printing to stderr\n                     (default \"info\")\n--no-color           switch to using an ASCII color profile within the terminal\n--no-log             disable all log output\n</code></pre>"},{"location":"reference/cli/nsv/","title":"nsv","text":"<pre><code>NSV (Next Semantic Version) is a convention-based semantic versioning tool that\nleans on the power of conventional commits to make versioning your software a\nbreeze!.\n\n## Why another versioning tool\n\nThere are many semantic versioning tools already out there! But they typically\nrequire some configuration or custom scripting in your CI system to make them\nwork. No one likes managing config; it is error-prone, and the slightest tweak\nultimately triggers a cascade of change across your projects.\n\nStep in NSV. Designed to make intelligent semantic versioning decisions about\nyour project without needing a config file. Entirely convention-based, you can\nadapt your workflow from within your commit message.\n\nThe power is at your fingertips.\n\nGlobal Environment Variables:\n\n| Name      | Description                                                  |\n|-----------|--------------------------------------------------------------|\n| LOG_LEVEL | the level of logging when printing to stderr (default: info) |\n| NO_COLOR  | switch to using an ASCII color profile within the terminal   |\n| NO_LOG    | disable all log output                                       |\n</code></pre>"},{"location":"reference/cli/nsv/#usage","title":"Usage","text":"<pre><code>nsv [command]\n</code></pre>"},{"location":"reference/cli/nsv/#commands","title":"Commands","text":"<pre><code>completion  Generate the autocompletion script for the specified shell\nhelp        Help about any command\nnext        Generate the next semantic version\nplayground  A playground for discovering go template support\ntag         Tag the repository with the next semantic version\nversion     Print build time version information\n</code></pre>"},{"location":"reference/cli/nsv/#flags","title":"Flags","text":"<pre><code>-h, --help               help for nsv\n    --log-level string   the level of logging when printing to stderr\n                         (default \"info\")\n    --no-color           switch to using an ASCII color profile within the\n                         terminal\n    --no-log             disable all log output\n</code></pre>"}]}